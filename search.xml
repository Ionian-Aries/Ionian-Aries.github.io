<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git学习笔记</title>
      <link href="/2022/05/06/git/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/05/06/git/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Git-学习笔记"><a href="#Git-学习笔记" class="headerlink" title="Git 学习笔记"></a>Git 学习笔记</h2><p>主要学习来源：<a href="https://www.bilibili.com/video/BV1MU4y1Y7h5">黑马</a></p><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>一般来说，团队合作开发的话，每个人都需要在自己的功能分支 <strong>feat&#x2F;XXX</strong> 上开发，最后一起合并到总的开发分支 <strong>dev</strong> 上，然后将开发分支 <strong>dev</strong> 合并到测试分支上，最后将测试分支合并到正式发布分支上。</p><p>其中总的开发分支一般叫做 <strong>dev</strong> 分支，正式发布分支一般是叫 <strong>main&#x2F;master&#x2F;release</strong> 分支。</p><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071625846.png"></p><p>比如说有 A、B、C 三个人协助进行功能开发：</p><ol><li>首先 A、B、C 三位小伙伴从总开发分支 Dev 上开辟自己的功能分支，分别是 feat&#x2F;AXXX、feat&#x2F;BXXX、feat&#x2F;CXXX，也就是图中 feat&#x2F;AXXX、feat&#x2F;BXXX、feat&#x2F;CXXX 的三条线；</li><li>然后在自己的开发机上进行开发，这里的开发机可以是本地环境也可以是一些云端的开发机。开发完毕后，再分别合到总开发分支 dev 上，也就是图中蓝色的三条线，在这个过程中可能会产生一些代码冲突，挨个 solve 即可；</li><li>接着在 dev 分支上确认所有功能开发完毕，进行简单自测，fix 一些 bug 后再向测试分支上进行合并；</li><li>这个时候就可以艾特测试组的同学来进行测试，测试通过后再合到 master 分支进行发布。</li></ol><p>一般来说，基本的流程就是这样的，不同公司或许其中流程有些出入，不过问题不大，大致方向是如此的。</p><h2 id="2-概述"><a href="#2-概述" class="headerlink" title="2 概述"></a>2 概述</h2><h3 id="2-1-版本控制的方式"><a href="#2-1-版本控制的方式" class="headerlink" title="2.1 版本控制的方式"></a>2.1 版本控制的方式</h3><ul><li>集中式版本控制工具：集中式版本控制工具，版本库是集中存放在中央服务器的，team 里每个人 work 时从中央服务器下载代码，是必须联网才能工作，局域网或互联网。个人修改后然后提交到中央版本库。<ul><li>举例：SVN 和 CVS</li></ul></li></ul><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071625510.png"></p><ul><li>分布式版本控制工具：分布式版本控制系统没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样工作的时候，无需要联网了，因为版本库就在你自己的电脑上。多人协作只需要各自的修改推送给对方，就能互相看到对方的修改了。<ul><li>举例：Git</li></ul></li></ul><h3 id="2-2-Git"><a href="#2-2-Git" class="headerlink" title="2.2 Git"></a>2.2 Git</h3><p>Git 是分布式的，Git 不需要有中心服务器，我们每台电脑拥有的东西都是一样的。我们使用 Git 并且有个中心服务器，仅仅是为了方便交换大家的修改，但是这个服务器的地位和我们每个人的 PC 是一样的。我们可以把它当做一个开发者的 pc 就可以就是为了大家代码容易交流不关机用的。没有它大家一样可以工作，只不过“交换”修改不方便而已。</p><p>git 是一个<strong>开源的分布式版本控制系统</strong>，可以有效、高速地处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众多的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002 年间）。到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代 码。</p><p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。 他们对新的系统制订了若干目标：</p><ul><li>速度</li><li>简单的设计</li><li>对非线性开发模式的强力支持（允许成千上万个并行开发的分支）</li><li>完全分布式</li><li>有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</li></ul><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071625954.png"></p><h3 id="2-3-Git-工作流程"><a href="#2-3-Git-工作流程" class="headerlink" title="2.3 Git 工作流程"></a>2.3 Git 工作流程</h3><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071625348.png"></p><p>命令如下：</p><ol><li>clone（克隆）: 从远程仓库中克隆代码到本地仓库</li><li>checkout （检出）:从本地仓库中检出一个仓库分支然后进行修订</li><li>add（添加）: 在提交前先将代码提交到暂存区</li><li>commit（提交）: 提交到本地仓库。本地仓库中保存修改的各个历史版本</li><li>fetch (抓取) ： 从远程库抓取到本地仓库，不进行任何的合并动作，一般操作比较少。</li><li>pull (拉取) ： 从远程库拉到本地库，自动进行合并(merge)，然后放到到工作区，相当于<br>fetch+merge</li><li>push（推送） : 修改完成后，需要和团队成员共享代码时，将代码推送到远程仓库</li></ol><h2 id="3-Git-安装与常用命令"><a href="#3-Git-安装与常用命令" class="headerlink" title="3 Git 安装与常用命令"></a>3 Git 安装与常用命令</h2><p>Git 命令例子都是在<strong>Git Bash</strong>中演示的，会用到一些基本的<strong>linux</strong>命令。</p><h3 id="3-1-Git-环境配置"><a href="#3-1-Git-环境配置" class="headerlink" title="3.1 Git 环境配置"></a>3.1 Git 环境配置</h3><h4 id="3-1-1-基本配置"><a href="#3-1-1-基本配置" class="headerlink" title="3.1.1 基本配置"></a>3.1.1 基本配置</h4><p><strong>下载安装</strong></p><p>安装完成后，在电脑桌面（也可以是其他目录）点击右键，如果能够看到如下两个菜单则说明 Git 安装成功。</p><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071625277.png"></p><ul><li><p>Git GUI：Git 提供的图形界面工具</p></li><li><p>Git Bash：Git 提供的命令行工具</p></li></ul><p>当安装 Git 后首先要做的事情是设置用户名称和 email 地址。这是非常重要的，因为每次 Git 提交都会使用该用户信息。</p><p><strong>基本配置</strong></p><ul><li>设置用户信息</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;XXX&quot;</span> <span class="comment"># 设置用户名</span></span><br><span class="line">git config --global user.email <span class="string">&quot;XXXX&quot;</span> <span class="comment"># 设置邮箱</span></span><br></pre></td></tr></table></figure><ul><li>查看配置信息</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name</span><br><span class="line">git config --global user.email</span><br></pre></td></tr></table></figure><h4 id="3-1-2-为常用指令配置别名"><a href="#3-1-2-为常用指令配置别名" class="headerlink" title="3.1.2 为常用指令配置别名"></a>3.1.2 为常用指令配置别名</h4><p>有些常用的指令参数非常多，每次都要输入好多参数，我们可以使用别名。</p><ul><li><p>打开用户目录，创建 .bashrc 文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> ~/.bashrc</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071625839.png"></p><ul><li>在 .bashrc 文件中输入如下内容：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用于输出git提交日志</span></span><br><span class="line"><span class="built_in">alias</span> git-log=<span class="string">&#x27;git log --pretty=oneline --all --graph --abbrev-commit&#x27;</span></span><br><span class="line"><span class="comment">#用于输出当前目录所有文件及基本信息</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -al&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071625220.png"></p><p><strong>注意</strong>：vi 退出编辑时，按 esc，输入冒号（英文），然后切换到最后一行模式，最后一行模式决定是否保存文件。例如输入 wq 保存并退出。</p><ul><li>打开 gitBash，执行：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="3-2-创建本地仓库"><a href="#3-2-创建本地仓库" class="headerlink" title="3.2 创建本地仓库"></a>3.2 创建本地仓库</h3><p>要使用 Git 对我们的代码进行版本控制，首先需要获得本地仓库</p><ol><li><p>在电脑的任意位置创建一个空目录（例如 test）作为我们的本地 Git 仓库</p></li><li><p>进入这个目录中，点击右键打开 Git bash 窗</p></li><li><p>执行命令 git init</p></li><li><p>如果创建成功后可在文件夹下看到隐藏的.git 目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071626298.png"></p></li></ol><h3 id="3-3-基础操作指令"><a href="#3-3-基础操作指令" class="headerlink" title="3.3 基础操作指令"></a>3.3 基础操作指令</h3><p>Git 工作目录下对于文件的修改(增加、删除、更新)会存在几个状态，这些修改的状态会随着我们执行 Git 的命令而发生变化。</p><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071626428.png"></p><p>本章节主要讲解如何使用命令来控制这些状态之间的转换：</p><ol><li>git add (工作区 —&gt; 暂存区)</li><li>git commit (暂存区 —&gt; 本地仓库)</li></ol><h4 id="3-3-1-status-查看修改的状态"><a href="#3-3-1-status-查看修改的状态" class="headerlink" title="3.3.1 status 查看修改的状态"></a>3.3.1 status 查看修改的状态</h4><p>作用：查看修改的状态（暂存区、工作区）</p><p>命令形式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><h4 id="3-3-2-add-添加工作区到暂存区"><a href="#3-3-2-add-添加工作区到暂存区" class="headerlink" title="3.3.2 add 添加工作区到暂存区"></a>3.3.2 add 添加工作区到暂存区</h4><ul><li>作用：添加工作区一个或多个文件的修改到暂存区</li><li>命令形式：git add 单个文件名|通配符</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add file.txt <span class="comment"># 添加单个文件</span></span><br><span class="line">git add . <span class="comment"># 将所有修改加入暂存区</span></span><br></pre></td></tr></table></figure><h4 id="3-3-3-commit-提交暂存区到本地仓库"><a href="#3-3-3-commit-提交暂存区到本地仓库" class="headerlink" title="3.3.3 commit 提交暂存区到本地仓库"></a>3.3.3 commit 提交暂存区到本地仓库</h4><ul><li>作用：提交暂存区内容到本地仓库的当前分支</li><li>命令形式：git commit -m ‘注释内容’</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;XXX update&quot;</span></span><br></pre></td></tr></table></figure><h4 id="3-3-4-log-查看提交日志"><a href="#3-3-4-log-查看提交日志" class="headerlink" title="3.3.4 log 查看提交日志"></a>3.3.4 log 查看提交日志</h4><p>配置的别名 git-log 就包含了这些参数，所以后续可以直接使用指令 git-log</p><ul><li><p>作用:查看提交记录</p></li><li><p>命令形式：git log [option] 或者 git-log</p><ul><li>—all 显示所有分支</li><li>—pretty&#x3D;oneline 将提交信息显示为一行</li><li>—abbrev-commit 使得输出的 commitId 更简短</li><li>—graph 以图的形式显示</li></ul></li></ul><h4 id="3-3-5-版本回退"><a href="#3-3-5-版本回退" class="headerlink" title="3.3.5 版本回退"></a>3.3.5 版本回退</h4><ul><li>作用：版本切换</li><li>命令形式：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commitID <span class="comment"># commitID 可以使用 git-log 或 git log 指令查看</span></span><br></pre></td></tr></table></figure><h4 id="3-3-6-添加文件至忽略列表"><a href="#3-3-6-添加文件至忽略列表" class="headerlink" title="3.3.6 添加文件至忽略列表"></a>3.3.6 添加文件至忽略列表</h4><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如<strong>日志文件</strong>，或者编译过程中创建的临时文件等。 在这种情况下，我们可以在工作目录中创建一个名为 <code>.gitignore</code> 的文件（文件名称固定），列出要忽略的文件模式。</p><h4 id="3-3-7-命令使用示例"><a href="#3-3-7-命令使用示例" class="headerlink" title="3.3.7 命令使用示例"></a>3.3.7 命令使用示例</h4><ul><li>利用上面初始化好的本地仓库 test，新建一个文件 file01.txt，并用 status 查看状态：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> file01.txt</span><br><span class="line">git status</span><br></pre></td></tr></table></figure><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071626231.png"></p><ul><li>添加到暂存区</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add file01.txt</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">git add .</span><br></pre></td></tr></table></figure><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071626523.png"></p><ul><li>提交至本地仓库并查看状态</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;commit file01.txt&quot;</span></span><br><span class="line">git status</span><br></pre></td></tr></table></figure><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071626214.png"></p><ul><li>查看日志</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071627765.png"></p><ul><li>修改 file01.txt 文件内容并查看状态</li></ul><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071627610.png"></p><ul><li>添加至暂存区并查看状态</li></ul><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071627075.png"></p><ul><li>提交至本地仓库并查看日志</li></ul><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071627249.png"></p><ul><li>利用 git-log 查看提交日志，并回退至第一个版本</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git-log</span><br><span class="line">git reset --hard XXXXX</span><br></pre></td></tr></table></figure><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071627961.png"></p><p>点击打开<code>file01.txt</code>，发现其中内容没有了。</p><p>同样，可以再次回到第二个版本：</p><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071627123.png"></p><ul><li>新建文件 file02.txt，加入.gitignore 中</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> file02.txt</span><br><span class="line"><span class="built_in">touch</span> .gitignore</span><br><span class="line">vi .gitignore <span class="comment"># 添加内容： file02.txt</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>.gitignore内容</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file02.txt</span><br><span class="line">也可以使用通配符，例如</span><br><span class="line">*.txt</span><br><span class="line">*.iml</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="3-4-分支"><a href="#3-4-分支" class="headerlink" title="3.4 分支"></a>3.4 分支</h3><p>几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来进行重大的 Bug 修改、开发新的功能，以免影响开发主线。</p><h4 id="3-4-1-查看本地分支"><a href="#3-4-1-查看本地分支" class="headerlink" title="3.4.1 查看本地分支"></a>3.4.1 查看本地分支</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><h4 id="3-4-2-创建本地分支"><a href="#3-4-2-创建本地分支" class="headerlink" title="3.4.2 创建本地分支"></a>3.4.2 创建本地分支</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 分支名</span><br></pre></td></tr></table></figure><h4 id="3-4-3-切换分支"><a href="#3-4-3-切换分支" class="headerlink" title="3.4.3 切换分支"></a>3.4.3 切换分支</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 分支名</span><br></pre></td></tr></table></figure><p>我们还可以直接切换到一个不存在的分支（创建并切换）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 分支名</span><br></pre></td></tr></table></figure><h4 id="3-4-4-合并分支"><a href="#3-4-4-合并分支" class="headerlink" title="3.4.4 合并分支"></a>3.4.4 合并分支</h4><p>一个分支上的提交可以合并到另一个分支</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge 分支名</span><br></pre></td></tr></table></figure><h4 id="3-4-5-删除分支"><a href="#3-4-5-删除分支" class="headerlink" title="3.4.5 删除分支"></a>3.4.5 删除分支</h4><p>不能删除当前分支，只能删除其他分支</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch -d 分支名 <span class="comment"># 删除分支时，需要做各种检查</span></span><br><span class="line"></span><br><span class="line">git branch -D 分支名 <span class="comment"># 不做任何检查，强制删除</span></span><br></pre></td></tr></table></figure><h4 id="3-4-6-解决冲突"><a href="#3-4-6-解决冲突" class="headerlink" title="3.4.6 解决冲突"></a>3.4.6 解决冲突</h4><p>当两个分支上对文件的修改可能会存在冲突，例如同时修改了同一个文件的同一行，这时就需要手动解决冲突，解决冲突步骤如下：</p><ol><li>处理文件中冲突的地方</li><li>将解决完冲突的文件加入暂存区(add)</li><li>提交到仓库(commit)</li></ol><h4 id="3-4-7-开发中分支使用原则与流程"><a href="#3-4-7-开发中分支使用原则与流程" class="headerlink" title="3.4.7 开发中分支使用原则与流程"></a>3.4.7 开发中分支使用原则与流程</h4><p>几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来进行重大的 Bug 修改、开发新的功能，以免影响开发主线。</p><p>在开发中，一般有如下分支使用原则与流程：</p><ol><li>master （生产） 分支：线上分支，主分支，中小规模项目作为线上运行的应用对应的分支；</li><li>develop（开发）分支：是从 master 创建的分支，一般作为开发部门的主要开发分支，如果没有其他并行开发不同期上线要求，都可以在此版本进行开发，阶段开发完成后，需要是合并到 master 分支，准备上线。</li><li>feature&#x2F;xxxx 分支：从 develop 创建的分支，一般是同期并行开发，但不同期上线时创建的分支，分支上的研发任务完成后合并到 develop 分支，之后该分支可以删除。</li><li>hotfix&#x2F;xxxx 分支：从 master 派生的分支，一般作为线上 bug 修复使用，修复完成后需要合并到 master、test、develop 分支。</li></ol><p>还有一些其他分支，在此不再详述，例如 test 分支（用于代码测试）、pre 分支（预上线分支）等<br>等。</p><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071628802.png"></p><h4 id="3-4-8-命令使用示例"><a href="#3-4-8-命令使用示例" class="headerlink" title="3.4.8 命令使用示例"></a>3.4.8 命令使用示例</h4><h5 id="1）-示例-1"><a href="#1）-示例-1" class="headerlink" title="1） 示例 1"></a>1） 示例 1</h5><p>查看分支，并新建分支 dev01</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br><span class="line">git branch dev01</span><br></pre></td></tr></table></figure><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071628551.png"></p><p>其中<strong>HEAD</strong>指向的是当前工作区所处的分支，例如此时处在<strong>master</strong>的分支上。</p><ul><li>将上一节中的<code>.gitignore</code>提交，并查看分支：</li></ul><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071628039.png"></p><ul><li>将当前分支切换到 dev01</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev01</span><br></pre></td></tr></table></figure><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071628556.png"></p><p>同时观察到，test 目录下的.gitignore 消失了</p><ul><li>重新切换到 master 分支，.gitignore 又出现了。新建分支 dev02，并同时切换到上面</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev02</span><br></pre></td></tr></table></figure><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071628878.png"></p><ul><li>切换到 dev01 分支，并新建文件 file03.txt，并提交</li></ul><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071628090.png"></p><ul><li>切换到 master 分支，并将 dev01 的提交合并到 master 上</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge dev01</span><br></pre></td></tr></table></figure><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071628975.png"></p><p>此时，可以看到在 master 分支下的仓库中，有了 file03.txt</p><ul><li>删除 dev02 分支</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d dev02</span><br></pre></td></tr></table></figure><h5 id="2）-示例-2——解决冲突"><a href="#2）-示例-2——解决冲突" class="headerlink" title="2） 示例 2——解决冲突"></a>2） 示例 2——解决冲突</h5><ul><li>删除分支 dev01，创建并切换到分支 dev 上。此时 master 和 dev 分支上的 file01.txt 文件中内容都为 update_count &#x3D; 1</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -d dev01</span><br><span class="line">git checkout -b dev</span><br></pre></td></tr></table></figure><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071628527.png"></p><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071628067.png"></p><ul><li>在 dev 分支上修改 file01.txt 文件内容为 update_count &#x3D; 2，并提交</li></ul><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071629165.png"></p><ul><li>在 master 分支上修改 file01.txt 文件内容为 update_count &#x3D; 3，并提交</li></ul><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071629235.png"></p><ul><li>将 dev 分支合并到 master 分支上，发现报错。查看 file01.txt 内容</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge dev</span><br></pre></td></tr></table></figure><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071629181.png"></p><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071629396.png"></p><ul><li>解决冲突：将<code>file01.txt</code>提示冲突的地方修改成我们想要的内容，例如再次修改成<code>update_count = 3</code>，并再次提交即可。</li></ul><h2 id="4-Git-远程仓库"><a href="#4-Git-远程仓库" class="headerlink" title="4 Git 远程仓库"></a>4 Git 远程仓库</h2><h3 id="4-1-常用的托管服务"><a href="#4-1-常用的托管服务" class="headerlink" title="4.1 常用的托管服务"></a>4.1 常用的托管服务</h3><p>前面我们已经知道了 Git 中存在两种类型的仓库，即本地仓库和远程仓库。那么我们如何搭建 Git 远程仓库呢？我们可以借助互联网上提供的一些代码托管服务来实现，其中比较常用的有 GitHub、码云、GitLab 等。</p><ul><li><p>GitHub（ 地址：<a href="https://github.com/">https://github.com/</a> ）是一个面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub</p></li><li><p>码云（地址： <a href="https://gitee.com/">https://gitee.com/</a> ）是国内的一个代码托管平台，由于服务器在国内，所以相比于 GitHub，码云速度会更快</p></li><li><p>GitLab （地址： <a href="https://about.gitlab.com/">https://about.gitlab.com/</a> ）是一个用于仓库管理系统的开源项目，使用 Git 作为代码管理工具，并在此基础上搭建起来的 web 服务，一般用于在企业、学校等内部网络搭建 git 私服。</p></li></ul><h3 id="4-2-操作远程仓库"><a href="#4-2-操作远程仓库" class="headerlink" title="4.2 操作远程仓库"></a>4.2 操作远程仓库</h3><h4 id="4-2-1-添加远程仓库"><a href="#4-2-1-添加远程仓库" class="headerlink" title="4.2.1 添加远程仓库"></a>4.2.1 添加远程仓库</h4><p>此操作是先初始化本地库，然后与已创建的远程库进行对接。</p><ul><li><p>命令：</p><ul><li>远端名称：默认是 origin，取决于远端服务器设置</li><li>仓库地址：从远端服务器获取此 url</li></ul></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add &lt;远端名称&gt; &lt;仓库地址&gt;</span><br></pre></td></tr></table></figure><ul><li>例如：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@gitee.com:czbk_zhang_meng/git_test.git</span><br></pre></td></tr></table></figure><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071629901.png"></p><h4 id="4-2-2-查看远程仓库"><a href="#4-2-2-查看远程仓库" class="headerlink" title="4.2.2 查看远程仓库"></a>4.2.2 查看远程仓库</h4><ul><li>命令：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure><h4 id="4-2-3-推送到远程仓库"><a href="#4-2-3-推送到远程仓库" class="headerlink" title="4.2.3 推送到远程仓库"></a>4.2.3 推送到远程仓库</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [-f] [--set-upstream][远端名称][本地分支名][:远端分支名]</span><br></pre></td></tr></table></figure><ul><li><p>命令：</p><p>如果远程分支名和本地分支名相同，则可以只写本地分支名</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br><span class="line">    + `-f`  表示强制推送，**一般在公司内没有这个的使用权限**，否则容易冲掉远程仓库的所有代码</span><br><span class="line">    + `--set-upstream` 推送到远端的同时，建立起和远端分支的关联关系。用于第一次推送时。</span><br></pre></td></tr></table></figure><ul><li>如果当前分支已经和远端分支关联，则可以省略分支名和远端名 + git push 将 master 分支推送到已关联的远端分支</li></ul><h4 id="4-2-4-本地分支与远程分支的关联关系"><a href="#4-2-4-本地分支与远程分支的关联关系" class="headerlink" title="4.2.4 本地分支与远程分支的关联关系"></a>4.2.4 本地分支与远程分支的关联关系</h4><ul><li>命令：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -vv</span><br></pre></td></tr></table></figure><h4 id="4-2-5-从远程仓库克隆"><a href="#4-2-5-从远程仓库克隆" class="headerlink" title="4.2.5 从远程仓库克隆"></a>4.2.5 从远程仓库克隆</h4><p>如果已经有一个远端仓库，我们可以直接 clone 到本地。</p><ul><li>命令：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;仓库地址&gt; [本地目录]</span><br></pre></td></tr></table></figure><p>本地目录可以省略，会自动生成一个目录</p><h4 id="4-2-6-从远程仓库中抓取和拉取"><a href="#4-2-6-从远程仓库中抓取和拉取" class="headerlink" title="4.2.6 从远程仓库中抓取和拉取"></a>4.2.6 从远程仓库中抓取和拉取</h4><p>远程分支和本地的分支一样，我们可以进行 merge 操作，只是需要先把远端仓库里的更新都下载到本地，再进行操作。</p><ul><li>抓取命令：<ul><li>抓取指令就是将仓库里的更新都抓取到本地，不会进行合并</li><li>如果不指定远端名称和分支名，则抓取所有分支。</li></ul></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch [remote name] [branch name]</span><br></pre></td></tr></table></figure><ul><li>拉取命令：<ul><li>拉取指令就是将远端仓库的修改拉到本地并自动进行合并，等同于 fetch+merge</li><li>如果不指定远端名称和分支名，则抓取所有并更新当前分支。</li></ul></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull [remote name] [branch name]</span><br></pre></td></tr></table></figure><h4 id="4-2-7-解决合并冲突"><a href="#4-2-7-解决合并冲突" class="headerlink" title="4.2.7 解决合并冲突"></a>4.2.7 解决合并冲突</h4><p>在一段时间，A、B 用户修改了同一个文件，且修改了同一行位置的代码，此时会发生合并冲突。</p><p>A 用户在本地修改代码后优先推送到远程仓库，此时 B 用户在本地修订代码，提交到本地仓库后，也需要推送到远程仓库，此时 B 用户晚于 A 用户，故需要先拉取远程仓库的提交，经过合并后才能推送到远端分支，如下图所示。</p><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071629439.png"></p><p>在 B 用户拉取代码时，因为 A、B 用户同一段时间修改了同一个文件的相同位置代码，故会发生合并冲突。</p><p><strong>远程分支也是分支，所以合并时冲突的解决方式也和解决本地分支冲突相同相同</strong>，在此不再赘述。</p><h3 id="4-3-命令使用示例"><a href="#4-3-命令使用示例" class="headerlink" title="4.3 命令使用示例"></a>4.3 命令使用示例</h3><h4 id="4-3-1-远程仓库添加查看推送"><a href="#4-3-1-远程仓库添加查看推送" class="headerlink" title="4.3.1 远程仓库添加查看推送"></a>4.3.1 远程仓库添加<em>查看</em>推送</h4><ul><li><p>初始化本地库（例如使用上一节创建的本地仓库 test），然后与已创建的远程库（例如创建将好一个远程仓库 git_test）进行对接</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@gitee.com:zeng-yiming/git_test.git</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071629723.png"></p><ul><li>查看对接好的远程仓库</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071630512.png"></p><p>推送到远程仓库</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>因为本地分支名 master 和远程分支名 master 同名，所以省略了远程分支名，完整的指令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master:master</span><br></pre></td></tr></table></figure><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071630933.png"></p><p>此时查看远端仓库，已有本地仓库的内容：</p><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071630712.png"></p><p>提交历史：</p><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071630737.png"></p><ul><li>查看本地分支与远程分支的绑定关系</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -vv</span><br></pre></td></tr></table></figure><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071630422.png"></p><p>此时尚未有绑定关系</p><ul><li>将本地分支 master 和远程分支 master 绑定关系</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin master:master</span><br></pre></td></tr></table></figure><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071630251.png"></p><p>发现本地分支 master 已经和远程分支 master 绑定成功</p><ol><li>此时本地分支 master 若要推送到远程分支 master 上，则可直接使用命令：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><h4 id="4-3-2-克隆-抓取和拉取"><a href="#4-3-2-克隆-抓取和拉取" class="headerlink" title="4.3.2 克隆_抓取和拉取"></a>4.3.2 克隆_抓取和拉取</h4><ol><li>克隆刚才的远程仓库 git_test，放在目录 git_test 中</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@gitee.com:zeng-yiming/git_test.git git_test</span><br></pre></td></tr></table></figure><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071630075.png"></p><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071630839.png"></p><ul><li>查看克隆仓库的日志</li></ul><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071630887.png"></p><ul><li>在本地仓库 test 中新建一个文件 file04.txt 并提交和推送</li></ul><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071630358.png"></p><p>发现由于<strong>快进模式</strong>，远端分支 master 也进入到了和本地仓库 test 的 master 分支相同的位置。</p><ul><li>本地仓库 git_test 从远端仓库抓取</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071630903.png"></p><ul><li>发现远端分支 master 比本地分支 master 的版本更新，因此进行合并</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge origin/master</span><br></pre></td></tr></table></figure><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071631463.png"></p><p>步骤 4 和 5 的指令可用一条指令完成：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><h4 id="4-3-3-解决冲突"><a href="#4-3-3-解决冲突" class="headerlink" title="4.3.3 解决冲突"></a>4.3.3 解决冲突</h4><ol><li>在本地仓库<code>test</code>和<code>git_test</code>中同时修改文件<code>file01.txt</code>，并提交，但是<code>test</code>首先推送至远端</li><li>在<code>test</code>推送后，<code>git_test</code>首先进行抓取</li></ol><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071631698.png"></p><p>发现远端分支已经有 test 的推送结果</p><ul><li>git_test 进行合并，提示冲突</li></ul><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071631001.png"></p><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071631165.png"></p><ul><li>解决冲突：将 file01.txt 的内容改成我们想要的，例如就改成 5，之后提交并推送即可</li></ul><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071631931.png"></p><h2 id="5-IDEA-中的-Git-使用"><a href="#5-IDEA-中的-Git-使用" class="headerlink" title="5 IDEA 中的 Git 使用"></a>5 IDEA 中的 Git 使用</h2><h3 id="5-1-配置-Git"><a href="#5-1-配置-Git" class="headerlink" title="5.1 配置 Git"></a>5.1 配置 Git</h3><p>略</p><h3 id="5-2-在-IDEA-中操作-Git"><a href="#5-2-在-IDEA-中操作-Git" class="headerlink" title="5.2 在 IDEA 中操作 Git"></a>5.2 在 IDEA 中操作 Git</h3><p>场景：本地已经有一个项目，但是并不是 git 项目，我们需要将这个放到码云的仓库里，和其他开发人员继续一起协作开发。</p><h4 id="5-2-1-创建项目的远程仓库"><a href="#5-2-1-创建项目的远程仓库" class="headerlink" title="5.2.1 创建项目的远程仓库"></a>5.2.1 创建项目的远程仓库</h4><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071631149.png"></p><h4 id="5-2-2-初始化本地仓库"><a href="#5-2-2-初始化本地仓库" class="headerlink" title="5.2.2 初始化本地仓库"></a>5.2.2 初始化本地仓库</h4><p><strong>初始化本地仓库</strong></p><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071631517.png"></p><p><strong>选择本项目</strong></p><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071632597.png"></p><h4 id="5-2-3-设置远程仓库"><a href="#5-2-3-设置远程仓库" class="headerlink" title="5.2.3 设置远程仓库"></a>5.2.3 设置远程仓库</h4><p><strong>查找选项</strong></p><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071632226.png"></p><p><strong>输入远程仓库地址</strong></p><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071632175.png"></p><h4 id="5-2-4-提交到本地仓库"><a href="#5-2-4-提交到本地仓库" class="headerlink" title="5.2.4 提交到本地仓库"></a>5.2.4 提交到本地仓库</h4><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071632082.png"></p><h4 id="5-2-5-推送到远程仓库"><a href="#5-2-5-推送到远程仓库" class="headerlink" title="5.2.5 推送到远程仓库"></a>5.2.5 推送到远程仓库</h4><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071632848.png"></p><h4 id="5-2-6-创建分支"><a href="#5-2-6-创建分支" class="headerlink" title="5.2.6 创建分支"></a>5.2.6 创建分支</h4><ul><li>方法一：最常规的方式</li></ul><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071632182.png"></p><ul><li>方法 2：最强大的方式</li></ul><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071633741.png"></p><h4 id="5-2-总结"><a href="#5-2-总结" class="headerlink" title="5.2 总结"></a>5.2 总结</h4><ul><li>在 IDEA 的终端中可使用 git 命令来完成以上所有功能</li><li>切换分支前先提交本地的修改</li><li>代码及时提交，提交过了就不会丢</li></ul><h2 id="6-Git-知识补充"><a href="#6-Git-知识补充" class="headerlink" title="6 Git 知识补充"></a>6 Git 知识补充</h2><h3 id="6-1-rebase-和-merge"><a href="#6-1-rebase-和-merge" class="headerlink" title="6.1 rebase 和 merge"></a>6.1 rebase 和 merge</h3><h4 id="6-1-1-HEAD-的理解"><a href="#6-1-1-HEAD-的理解" class="headerlink" title="6.1.1 HEAD 的理解"></a>6.1.1 HEAD 的理解</h4><p><code>HEAD</code> 指向当前所在的分支，类似一个活动的指针，表示一个「引用」。</p><p><code>HEAD</code> 既可以指向「当前分支」的最新 <code>commit</code>，也可以指向历史中的某一次 <code>commit</code> (「分离头指针」的情况)。归根结底，<code>HEAD</code> 指向的就是某个提交点。</p><p>当我们做分支切换时，<code>HEAD</code> 会跟着切换到对应分支。</p><h4 id="6-1-2-fast-forward-与-—no-ff-的区别"><a href="#6-1-2-fast-forward-与-—no-ff-的区别" class="headerlink" title="6.1.2 fast-forward 与 —no-ff 的区别"></a>6.1.2 fast-forward 与 —no-ff 的区别</h4><p>假如有一个场景：有两个分支，master 分支和 feature 分支。现在，feautre 分支需要合并回 master 分支。</p><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071633947.png"></p><ul><li>fast-forward 合并方式是条件允许的情况，通过将 master 分支的 HEAD 位置移动到 feature 分支的最新提交点上，这样就实现了快速合并。这种情况，是不会新生成 commit 的。（快进模式）</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master <span class="comment"># 先切换到master分支</span></span><br><span class="line">git merge feature <span class="comment"># 将feature分支合并到当前分支上（master）</span></span><br></pre></td></tr></table></figure><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071633109.png"></p><ul><li>–no-ff 的方式进行合并，master 分支就会新生成一次提交记录。</li></ul><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071633906.png"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master <span class="comment"># 先切换到master分支</span></span><br><span class="line">git merge --no-ff feature <span class="comment"># 将feature分支合并到当前分支上（master）</span></span><br></pre></td></tr></table></figure><p>如果条件满足时，merge 默认采用的 fast-forward 方式进行合并，除非你显示的加上 –no-ff 选项；而条件不满足时，merge 也是无法使用 fast-forward 合并成功的！</p><h4 id="6-1-3-merge-操作"><a href="#6-1-3-merge-操作" class="headerlink" title="6.1.3 merge 操作"></a>6.1.3 merge 操作</h4><p><code>git merge</code> 操作是区分上下文的。当前分支始终是目标分支，其他一个或多个分支始终合并到当前分支。这个注意点记住了，方便记忆！所以，当需要将某个分支合并到目标分支时，需要先切到目标分支上。</p><p><strong>条件满足的含义</strong></p><p>快进模式能够进行的条件是：<strong>源分支和目标分支之间没有分叉</strong>。下图则是无法通过 HEAD 的快速移动实现分支的合并。</p><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071633967.png"></p><p>如果执行合并操作，默认会尝试 fast-forward 的方式进行合并，但是因为分叉了，所以此时会采用 no-ff 的方式进行合并，有新的 commit 生成了。最终的结果图如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master <span class="comment"># 先切换到目标分支</span></span><br><span class="line">git merge feature</span><br></pre></td></tr></table></figure><h4 id="6-1-4-rebase-操作"><a href="#6-1-4-rebase-操作" class="headerlink" title="6.1.4 rebase 操作"></a>6.1.4 rebase 操作</h4><p>rebase 合并往往又被称为 「变基」。这里的「基」就是一个「基点」、「起点」的意思。git rebase 命令通常称为向前移植（forward porting）。</p><p>「变基」就是改变当前分支的起点。注意，是当前分支！ rebase 命令后面紧接着的就是「基分支」。与 merge 操作相反。</p><ul><li>变基前：</li></ul><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071634250.png"></p><ul><li>执行命令：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- git checkout feature <span class="comment"># 切换到当前分支，或待变基分支</span></span><br><span class="line">- git rebase master <span class="comment"># 变基</span></span><br><span class="line"><span class="comment">#可合并为下面的语句</span></span><br><span class="line">git rebase master feature</span><br></pre></td></tr></table></figure><ul><li>变基后：</li></ul><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071634708.png"></p><ul><li>解释：rebase，变基，可以直接理解为改变基底。feature 分支是基于 master 分支的 B 拉出来的分支，feature 的基底是 B。而 master 在 B 之后有新的提交，就相当于此时要用 master 上新的提交来作为 feature 分支的新基底。实际操作为把 B 之后 feature 的提交存下来，然后删掉原来这些提交，再找到 master 的最新提交位置，把存下来的提交再接上去（新节点新 commit id），如此 feature 分支的基底就相当于变成了 E 而不是原来的 B 了。（注意，如果 master 上在 B 以后没有新提交，那么就还是用原来的 B 作为基，rebase 操作相当于无效，此时和 git merge 就基本没区别了，差异只在于 git merge 会多一条记录 Merge 操作的提交记录）</li></ul><p><strong>推荐使用场景</strong></p><ul><li><p>往公共分支上合代码的时候，推荐使用 merge。</p></li><li><p>拉公共分支最新代码的时候，推荐使用 rebase，也就是 git pull -r 或 git pull –rebase，但有个缺点就是 rebase 以后我就不知道我的当前分支最早是从哪个分支拉出来的了，因为基底变了嘛。</p></li></ul><p><strong>图示</strong></p><p>从 Develop 分支分出两个分支，分属两个人员进行开发。F1 分支开发完毕后，push 到总分支。F2 分支开发到 F2_5 时需要拉取最新代码。</p><ul><li>如果 F2 分支采用 git pull 拉取最新代码：<ul><li>F1 分支的视角（F1 分支的 commit 记录）：</li></ul></li></ul><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071634534.png"></p><ul><li>F2 分支的视角：这将会把 F1 分支的修改直接拉下来于本地代码 merge，且产生一个 commit F2_5，也就是 merge commit。</li></ul><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071634648.png"></p><ul><li>如果 F2 分支采用 git pull –rebase 拉取最新代码：<ul><li>F1 分支视角不变</li><li>F2 分支视角：</li></ul></li></ul><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071634387.png"></p><h3 id="6-2-强制拉取到本地仓库"><a href="#6-2-强制拉取到本地仓库" class="headerlink" title="6.2 强制拉取到本地仓库"></a>6.2 强制拉取到本地仓库</h3><p>有些时候本地仓库提交管理混乱，需要从远程仓库强制拉取，以刷新本地仓库，覆盖所有 add 和 commit 操作。可执行以下代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all</span><br><span class="line">git reset --hard origin/master</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><h3 id="6-3-远程分支合并"><a href="#6-3-远程分支合并" class="headerlink" title="6.3 远程分支合并"></a>6.3 远程分支合并</h3><p>该项职责由 git 管理员来完成。例如当开发分支 Develop 上的所有功能已经完成时，需要合并到 master 上时：</p><ul><li>代码 clone 到本地仓库</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span></span><br></pre></td></tr></table></figure><ul><li>在本地创建 dev 分支并与远程 dev 分支对应</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><ul><li>切换到 master 分支</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><ul><li>本地的 dev 合并到 master 上（遇到冲突解决完后再次提交）</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge dev</span><br></pre></td></tr></table></figure><ul><li>推送到远程的 master 上（执行这项操作时，需要有操作远程 master 分支的权限）</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071634857.png"></p><ul><li>释放权限：</li></ul><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071634866.png"></p><ul><li>操作结果：</li></ul><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071635354.png"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图库</title>
      <link href="/2021/06/11/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/"/>
      <url>/2021/06/11/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<p><a href="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071638225.png">https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071638225.png</a></p><p><a href="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071638728.png">https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071638728.png</a></p><p><a href="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071638880.png">https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071638880.png</a></p><p><a href="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071638238.png">https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071638238.png</a></p><p><a href="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071638430.jpg">https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071638430.jpg</a></p><p><a href="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071638126.png">https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071638126.png</a></p><p><a href="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071638136.png">https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071638136.png</a></p><p><a href="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071639020.png">https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071639020.png</a></p><p><a href="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071639756.png">https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071639756.png</a></p><p><a href="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071639751.png">https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071639751.png</a></p><p><a href="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071639853.png">https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071639853.png</a></p><p><a href="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071639853.png">https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071639853.png</a></p><p><a href="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071639344.jpg">https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071639344.jpg</a></p><p><a href="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071639957.jpg">https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071639957.jpg</a></p><p><a href="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071639865.jpg">https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071639865.jpg</a></p>]]></content>
      
      
      <categories>
          
          <category> 演示 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建</title>
      <link href="/2021/05/26/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2021/05/26/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1.环境搭建"></a>1.环境搭建</h1><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071611315.png" alt="image-20220504131711053"></p><h1 id="2-使用-hexo-搭建博客"><a href="#2-使用-hexo-搭建博客" class="headerlink" title="2.使用 hexo 搭建博客"></a>2.使用 hexo 搭建博客</h1><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071611317.png" alt="image-20220504131716049"></p><ul><li><p>本地化运行博客：hexo s</p></li><li><p>创建文章：hexo n “文章标题”</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">D</span>:\<span class="title class_">Blog</span>&gt;hexo n <span class="string">&quot;第一篇博客&quot;</span></span><br><span class="line"><span class="variable constant_">INFO</span>  <span class="title class_">Validating</span> config</span><br><span class="line"><span class="variable constant_">INFO</span>  <span class="title class_">Created</span>: <span class="attr">D</span>:\<span class="title class_">Blog</span>\source\_posts\第一篇博客.<span class="property">md</span></span><br></pre></td></tr></table></figure><ul><li>更新文章<ul><li>hexo clean:清理缓存</li><li>hexo g:解析生成</li><li>hexo s :预览</li></ul></li></ul><h1 id="3-将博客部署到-github"><a href="#3-将博客部署到-github" class="headerlink" title="3.将博客部署到 github"></a>3.将博客部署到 github</h1><p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071611318.png" alt="image-20220504134029610"></p><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071611319.png" alt="image-20220504141119903" style="zoom:50%;" /><ul><li><p>hexo clean:清理缓存</p></li><li><p>hexo g:解析生成</p></li><li><p>hexo d：推导 github</p></li></ul><h1 id="4-更换主题"><a href="#4-更换主题" class="headerlink" title="4.更换主题"></a>4.更换主题</h1><img src="https://typorazhh.oss-cn-nanjing.aliyuncs.com/202205071611320.png" alt="image-20220504142911931" style="zoom:50%;" /><h1 id="5-git-版本控制"><a href="#5-git-版本控制" class="headerlink" title="*5.git 版本控制"></a>*5.git 版本控制</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git init <span class="comment">//初始化git</span></span><br><span class="line">git add . <span class="comment">//添加所有文件到暂存区</span></span><br><span class="line">git commit -m <span class="string">&quot;初始化仓库&quot;</span>   <span class="comment">//提交到本地 -m后面是提交简介</span></span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin <span class="attr">https</span>:<span class="comment">//github.com/ionian-aries/blog.git //更改源</span></span><br><span class="line">git push -u origin main  <span class="comment">//推动到远程</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone <span class="attr">https</span>:<span class="comment">//github.com/Ionian-Aries/Blog.git   //完整的克隆</span></span><br><span class="line">npm i <span class="comment">//安装依赖</span></span><br></pre></td></tr></table></figure><p>解决方法：<br>1、添加到本地仓库</p><p>git add .</p><p>2、添加提交描述</p><p>git commit -m ‘提交’</p><p>3、提交前先从远程仓库主分支中拉取请求</p><p>git pull origin main</p><p>4、把本地仓库代码提交</p><p>git push -u origin main</p><h1 id="6-picgo-图床"><a href="#6-picgo-图床" class="headerlink" title="6.picgo 图床"></a>6.picgo 图床</h1><ul><li>截图保存，粘贴在 typora 中</li><li><code>ctrl+shift+u</code>上传图片到 github 图床，然后直接复制链接</li><li>替换图片中的地址</li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搭建 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
